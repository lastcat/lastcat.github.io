<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ピアノの達人</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+JP:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Inter", "Noto Sans JP", sans-serif;
        touch-action: manipulation;
        background: linear-gradient(
          135deg,
          #f06,
          #f90
        ); /* 太鼓の達人風のグラデーション */
      }
      .result-animation {
        animation: pop-fade 0.8s ease-out forwards;
      }
      @keyframes pop-fade {
        0% {
          transform: scale(0.5);
          opacity: 0;
        }
        50% {
          transform: scale(1.5);
          opacity: 1;
        } /* より大きく */
        100% {
          transform: scale(1);
          opacity: 0;
        }
      }
      #game-over-screen {
        background-color: rgba(0, 0, 0, 0.85); /* より濃いオーバーレイ */
      }
      .white-key {
        border: 1px solid #9ca3af;
        background-color: white;
        position: absolute;
        bottom: 0;
        cursor: pointer;
        transition: background-color 0.1s;
        border-radius: 0 0 5px 5px;
      }
      .white-key:hover {
        background-color: #e5e7eb;
      }
      .white-key.active {
        background-color: #d1d5db;
      }

      .black-key {
        background-color: #1f2937;
        position: absolute;
        top: 0;
        z-index: 10;
        cursor: pointer;
        transition: background-color 0.1s;
        border-radius: 0 0 5px 5px;
        border: 2px solid #4b5563;
      }
      .black-key:hover {
        background-color: #374151;
      }
      .black-key.active {
        background-color: #111827;
      }

      .difficulty-btn.active {
        background-color: #3b82f6;
        color: white;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
      }
    </style>
  </head>
  <body
    class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4"
  >
    <div class="w-full max-w-4xl mx-auto bg-white rounded-xl shadow-lg p-6">
      <header class="text-center mb-4">
        <h1
          class="text-4xl font-bold text-gray-800"
          style="color: #e33; text-shadow: 2px 2px #ffc107"
        >
          ピアノの達人
        </h1>
        <p class="text-gray-500 mt-1">目指せ、ピアノマスター！</p>
      </header>

      <div
        class="flex flex-col md:flex-row justify-between items-center gap-4 mb-4 p-4 bg-blue-50 rounded-lg border border-blue-200"
      >
        <button
          id="connect-midi"
          class="w-full md:w-auto bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-6 rounded-lg transition-colors shadow-md focus:outline-none focus:ring-2 focus:ring-blue-400"
        >
          Bluetooth MIDIに接続
        </button>
        <div class="flex items-center gap-4 flex-wrap justify-center">
          <div class="flex items-center gap-2 bg-gray-200 p-1 rounded-lg">
            <button
              data-difficulty="Easy"
              class="difficulty-btn active px-3 py-1 text-sm font-semibold rounded-md transition-colors"
            >
              Easy
            </button>
            <button
              data-difficulty="Normal"
              class="difficulty-btn px-3 py-1 text-sm font-semibold rounded-md transition-colors"
            >
              Normal
            </button>
          </div>
          <div class="flex items-center gap-2">
            <label for="speed-slider" class="text-sm font-medium text-gray-700"
              >速さ:</label
            >
            <input
              id="speed-slider"
              type="range"
              min="0.5"
              max="3"
              value="1"
              step="0.1"
              class="w-24"
            />
            <span
              id="speed-value"
              class="text-sm font-semibold text-gray-700 w-8 text-left"
              >1.0</span
            >
          </div>
          <div class="flex items-center gap-2">
            <label for="volume-slider" class="text-sm font-medium text-gray-700"
              >音量:</label
            >
            <input
              id="volume-slider"
              type="range"
              min="0"
              max="1"
              value="0.4"
              step="0.01"
              class="w-24"
            />
            <span
              id="volume-value"
              class="text-sm font-semibold text-gray-700 w-10 text-left"
              >0.40</span
            >
          </div>
        </div>
        <div
          id="status"
          class="text-center md:text-left text-blue-800 bg-blue-100 px-4 py-2 rounded-md text-sm"
        >
          接続待機中...
        </div>
      </div>
      <div class="flex justify-between items-center mb-2 px-2">
        <div class="flex items-center gap-4">
          <div
            id="key-display"
            class="text-lg font-semibold text-gray-700 bg-blue-100 px-3 py-1 rounded-md"
          >
            キー: C Major
          </div>
          <div
            id="chord-display"
            class="text-lg font-bold text-indigo-600 hidden"
          >
            コード: C
          </div>
        </div>
        <div id="score" class="text-xl font-semibold text-gray-700">
          スコア: <span id="correct-count">0</span> /
          <span id="total-count">0</span> (<span id="accuracy">0</span>%)
        </div>
      </div>

      <div
        class="relative w-full aspect-[3/1] bg-gray-50 border-2 border-gray-200 rounded-lg overflow-hidden shadow-inner"
        style="
          background: url('data:image/svg+xml,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'100\' height=\'100\' viewBox=\'0 0 100 100\'><circle cx=\'50\' cy=\'50\' r=\'30\' fill=\'%23fee\' opacity=\'0.5\'/><circle cx=\'50\' cy=\'50\' r=\'20\' fill=\'%23fdd\' opacity=\'0.5\'/></svg>');
          background-size: 50px;
          background-color: #ffe0b2;
        "
      >
        <canvas id="staff-canvas"></canvas>
        <div
          id="result-display"
          class="absolute top-1/2 left-1/3 -translate-x-1/2 -translate-y-1/2 text-8xl font-bold pointer-events-none"
          style="text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5)"
        ></div>
        <div
          id="game-over-screen"
          class="absolute inset-0 bg-black bg-opacity-70 flex-col items-center justify-center text-white hidden"
        >
          <h2
            class="text-4xl font-bold mb-4"
            style="color: #ffcc00; text-shadow: 2px 2px #e33"
          >
            ゲーム終了！
          </h2>
          <p class="text-2xl mb-8" style="color: #fff">
            スコア: <span id="final-score">0</span> /
            <span id="final-max-score">10</span>
          </p>
          <button
            id="restart-button"
            class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-lg text-xl transition-colors shadow-lg"
          >
            もう一度プレイ！
          </button>
        </div>
      </div>

      <div id="piano-keyboard" class="w-full h-40 relative mt-6"></div>
    </div>

    <script>
      // DOM要素の取得
      const connectButton = document.getElementById("connect-midi");
      const statusDisplay = document.getElementById("status");
      const canvas = document.getElementById("staff-canvas");
      const ctx = canvas.getContext("2d");
      const resultDisplay = document.getElementById("result-display");
      const correctCountSpan = document.getElementById("correct-count");
      const totalCountSpan = document.getElementById("total-count");
      const accuracySpan = document.getElementById("accuracy");
      const gameOverScreen = document.getElementById("game-over-screen");
      const finalScoreSpan = document.getElementById("final-score");
      const finalMaxScoreSpan = document.getElementById("final-max-score");
      const restartButton = document.getElementById("restart-button");
      const speedSlider = document.getElementById("speed-slider");
      const speedValueSpan = document.getElementById("speed-value");
      const volumeSlider = document.getElementById("volume-slider");
      const volumeValueSpan = document.getElementById("volume-value");
      const keyDisplay = document.getElementById("key-display");
      const chordDisplay = document.getElementById("chord-display");
      const difficultyButtons = document.querySelectorAll(".difficulty-btn");

      // --- ゲームの状態管理 ---
      let notesOnScreen = [];
      let score = { correct: 0, total: 0, max: 10 };
      let gameRunning = false;
      let textEffects = [];
      let highlightEffects = [];
      let noteSpeed = 1;
      let volume = 0.4;
      let audioCtx;
      let currentKeyName = "C Major";
      let difficulty = "Easy";
      let currentProgression = [];
      let currentChordIndex = 0;
      let currentNoteInChordIndex = 0; // Normalモードでコード内の何番目の音かを管理

      // --- 定数設定 ---
      const EASY_GAME_LENGTH = 10;
      const NORMAL_GAME_CHORDS = 4;
      const NOTE_GENERATION_INTERVAL = 2000; // 1つのコードあたりの時間
      const JUDGEMENT_LINE_X = canvas.width / 3;
      const JUDGEMENT_AREA_WIDTH = 40;
      const C4_Y = 140; // MIDI note 60 (Middle C)
      const Y_STEP = 10; // 五線譜の線/間の間隔

      const noteBaseSteps = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6];
      const jaNoteNamesSharp = [
        "ド",
        "ド♯",
        "レ",
        "レ♯",
        "ミ",
        "ファ",
        "ファ♯",
        "ソ",
        "ソ♯",
        "ラ",
        "ラ♯",
        "シ",
      ];
      const jaNoteNamesFlat = [
        "ド",
        "レ♭",
        "レ",
        "ミ♭",
        "ミ",
        "ファ",
        "ソ♭",
        "ソ",
        "ラ♭",
        "ラ",
        "シ♭",
        "シ",
      ];

      const SCALES = {
        "C Major": {
          notes: [
            { midi: 60, step: 0 },
            { midi: 62, step: 1 },
            { midi: 64, step: 2 },
            { midi: 65, step: 3 },
            { midi: 67, step: 4 },
            { midi: 69, step: 5 },
            { midi: 71, step: 6 },
          ],
          signature: [],
          chords: {
            I: { name: "C", notes: [60, 64, 67] },
            ii: { name: "Dm", notes: [62, 65, 69] },
            iii: { name: "Em", notes: [64, 67, 71] },
            IV: { name: "F", notes: [65, 69, 72] },
            V: { name: "G", notes: [67, 71, 74] },
            vi: { name: "Am", notes: [69, 72, 76] },
            "vii°": { name: "Bdim", notes: [71, 74, 77] },
          },
          progressions: [
            ["I", "V", "vi", "IV"],
            ["I", "IV", "V", "I"],
            ["vi", "IV", "I", "V"],
            ["I", "V_inv1", "vi", "IV_inv2"], // 展開形を含む進行
          ],
        },
        "G Major": {
          notes: [
            { midi: 55, step: 4 },
            { midi: 57, step: 5 },
            { midi: 59, step: 6 },
            { midi: 60, step: 0 },
            { midi: 62, step: 1 },
            { midi: 64, step: 2 },
            { midi: 66, step: 3 },
          ],
          signature: [{ midi: 77, type: "♯" }],
          chords: {
            I: { name: "G", notes: [55, 59, 62] },
            ii: { name: "Am", notes: [57, 60, 64] },
            iii: { name: "Bm", notes: [59, 62, 66] },
            IV: { name: "C", notes: [60, 64, 67] },
            V: { name: "D", notes: [62, 66, 69] },
            vi: { name: "Em", notes: [64, 67, 71] },
            "vii°": { name: "F#dim", notes: [66, 69, 72] },
          },
          progressions: [
            ["I", "V", "vi", "IV"],
            ["I", "IV", "V", "I"],
            ["vi", "IV", "I", "V"],
            ["I", "V_inv1", "vi", "IV"], // 展開形を含む進行
          ],
        },
        "F Major": {
          notes: [
            { midi: 53, step: 3 },
            { midi: 55, step: 4 },
            { midi: 57, step: 5 },
            { midi: 58, step: 6 },
            { midi: 60, step: 0 },
            { midi: 62, step: 1 },
            { midi: 64, step: 2 },
          ],
          signature: [{ midi: 71, type: "♭" }],
          chords: {
            I: { name: "F", notes: [53, 57, 60] },
            ii: { name: "Gm", notes: [55, 58, 62] },
            iii: { name: "Am", notes: [57, 60, 64] },
            IV: { name: "Bb", notes: [58, 62, 65] },
            V: { name: "C", notes: [60, 64, 67] },
            vi: { name: "Dm", notes: [62, 65, 69] },
            "vii°": { name: "Edim", notes: [64, 67, 70] },
          },
          progressions: [
            ["I", "V", "vi", "IV"],
            ["I", "IV", "V", "I"],
            ["vi", "IV", "I", "V"],
            ["IV", "V", "I_inv1", "vi"], // 展開形を含む進行
          ],
        },
      };
      const KEY_NAMES = Object.keys(SCALES);

      // --- ユーティリティ関数 ---
      function getNoteInfo(midiNote, keyName = "C Major") {
        const names =
          keyName.includes("b") || keyName.includes("F Major")
            ? jaNoteNamesFlat
            : jaNoteNamesSharp;
        const octave = Math.floor(midiNote / 12) - 1;
        const noteIndex = midiNote % 12;
        const C4_octave = 4;
        const octaveOffset = (octave - C4_octave) * 7;
        const stepWithinOctave = noteBaseSteps[noteIndex];
        const totalStepsFromC4 = stepWithinOctave + octaveOffset;
        const y = C4_Y - totalStepsFromC4 * Y_STEP;
        const name = names[noteIndex];
        return { note: midiNote, y: y, name: name };
      }

      /**
       * コード進行のローマ数字から、展開形を考慮したコードオブジェクトを生成する
       * @param {string} keyName - 現在のキー名 ("C Major"など)
       * @param {string} romanWithInversion - 展開情報を含むローマ数字 ("V_inv1"など)
       * @returns {{name: string, notes: number[]}|null} - コード名とMIDIノート配列を持つオブジェクト
       */
      function getChordFromProgression(keyName, romanWithInversion) {
        let roman = romanWithInversion;
        let inversion = 0;

        if (roman.includes("_inv1")) {
          inversion = 1;
          roman = roman.replace("_inv1", "");
        } else if (roman.includes("_inv2")) {
          inversion = 2;
          roman = roman.replace("_inv2", "");
        }

        const originalChord = SCALES[keyName].chords[roman];
        if (!originalChord) return null;

        let finalChord = {
          name: originalChord.name,
          notes: [...originalChord.notes],
        };

        const keyUsesFlats =
          keyName.includes("b") || keyName.includes("F Major");
        const noteNames = keyUsesFlats ? jaNoteNamesFlat : jaNoteNamesSharp;

        if (inversion === 1 && finalChord.notes.length > 1) {
          const root = finalChord.notes.shift();
          finalChord.notes.push(root + 12);
          const bassNoteName = noteNames[finalChord.notes[0] % 12];
          finalChord.name = `${originalChord.name}/${bassNoteName}`;
        } else if (inversion === 2 && finalChord.notes.length > 2) {
          const root = finalChord.notes.shift();
          const third = finalChord.notes.shift();
          finalChord.notes.push(root + 12, third + 12);
          const bassNoteName = noteNames[finalChord.notes[0] % 12];
          finalChord.name = `${originalChord.name}/${bassNoteName}`;
        }

        finalChord.notes.sort((a, b) => a - b);
        return finalChord;
      }

      // --- Canvasのサイズ調整 ---
      function resizeCanvas() {
        const parent = canvas.parentElement;
        canvas.width = parent.clientWidth;
        canvas.height = parent.clientHeight;
        Object.defineProperty(window, "JUDGEMENT_LINE_X", {
          value: canvas.width / 3,
          writable: false,
          configurable: true,
        });
        draw();
      }

      // --- 描画関連 ---
      function drawStaff() {
        const staffLineMidiNotes = [64, 67, 71, 74, 77]; // E4, G4, B4, D5, F5
        const staffLinesY = staffLineMidiNotes.map(
          (midi) => getNoteInfo(midi).y
        );

        ctx.strokeStyle = "#9ca3af";
        ctx.lineWidth = 2;
        staffLinesY.forEach((y) => {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        });

        const G4_Y = staffLinesY[1];
        ctx.font = "120px serif";
        ctx.fillStyle = "#374151";
        ctx.textBaseline = "middle";
        ctx.fillText("𝄞", 10, G4_Y + 10);
        ctx.textBaseline = "alphabetic";

        const clefMetrics = ctx.measureText("𝄞");

        const signature = SCALES[currentKeyName].signature;
        ctx.font = "45px serif";
        ctx.textBaseline = "middle";
        let xPos = 10 + clefMetrics.width + 15;
        signature.forEach((accidental) => {
          const noteInfo = getNoteInfo(accidental.midi);
          ctx.fillText(accidental.type, xPos, noteInfo.y);
          xPos += 20;
        });
        ctx.textBaseline = "alphabetic";

        ctx.strokeStyle = "#FF4500";
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(JUDGEMENT_LINE_X, 0);
        ctx.lineTo(JUDGEMENT_LINE_X, canvas.height);
        ctx.stroke();
        ctx.fillStyle = "#FF4500";
        ctx.beginPath();
        ctx.arc(JUDGEMENT_LINE_X, canvas.height / 2, 20, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawNote(note) {
        const lineSpacing = 20;
        const staffTop = getNoteInfo(77).y;
        const staffBottom = getNoteInfo(64).y;
        ctx.save();
        ctx.strokeStyle = "#374151";
        ctx.lineWidth = 2;
        if (note.y > staffBottom) {
          for (
            let y = staffBottom + lineSpacing;
            y <= note.y + 1;
            y += lineSpacing
          ) {
            ctx.beginPath();
            ctx.moveTo(note.x - 20, y);
            ctx.lineTo(note.x + 20, y);
            ctx.stroke();
          }
        }
        if (note.y < staffTop) {
          for (
            let y = staffTop - lineSpacing;
            y >= note.y - 1;
            y -= lineSpacing
          ) {
            ctx.beginPath();
            ctx.moveTo(note.x - 20, y);
            ctx.lineTo(note.x + 20, y);
            ctx.stroke();
          }
        }
        ctx.restore();

        ctx.fillStyle = "#1f2937";
        ctx.strokeStyle = "#1f2937";
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.ellipse(note.x, note.y, 14, 10, -0.3, 0, Math.PI * 2);
        ctx.fill();

        if (note.judged) {
          ctx.fillStyle = note.correct
            ? "rgba(34, 197, 94, 0.7)"
            : "rgba(239, 68, 68, 0.7)";
          ctx.beginPath();
          ctx.ellipse(note.x, note.y, 16, 12, -0.3, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawTextEffects() {
        ctx.font = 'bold 30px "Noto Sans JP", sans-serif';
        ctx.textAlign = "center";
        textEffects.forEach((effect) => {
          ctx.save();
          ctx.fillStyle = effect.color;
          ctx.globalAlpha = Math.max(0, effect.life / 60);
          ctx.fillText(effect.text, effect.x, effect.y);
          ctx.restore();
        });
      }

      function drawHighlights() {
        highlightEffects.forEach((effect) => {
          ctx.save();
          ctx.globalAlpha = Math.max(0, effect.life / 30) * 0.8;
          ctx.fillStyle = "#ffc107";
          ctx.shadowColor = "#ffc107";
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(JUDGEMENT_LINE_X, effect.y, 12, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      // --- ゲームロジック ---
      function generateNote() {
        if (!gameRunning || score.total >= score.max) return;

        if (difficulty === "Easy") {
          // Easy Mode Logic
          const scaleNoteObjects = SCALES[currentKeyName].notes;
          let finalMidiNote = -1;
          let baseNoteObject;
          while (finalMidiNote === -1) {
            baseNoteObject =
              scaleNoteObjects[
                Math.floor(Math.random() * scaleNoteObjects.length)
              ];
            const validNotes = [];
            for (const oct of [-1, 0, 1, 2]) {
              const transposedMidi = baseNoteObject.midi + oct * 12;
              if (transposedMidi >= 60 && transposedMidi <= 79)
                validNotes.push(transposedMidi);
            }
            if (validNotes.length > 0)
              finalMidiNote =
                validNotes[Math.floor(Math.random() * validNotes.length)];
          }
          const midiNote = finalMidiNote;
          const octave = Math.floor(midiNote / 12) - 1;
          const C4_octave = 4;
          const octaveOffset = (octave - C4_octave) * 7;
          const totalStepsFromC4 = baseNoteObject.step + octaveOffset;
          const y = C4_Y - totalStepsFromC4 * Y_STEP;
          const names =
            currentKeyName.includes("b") || currentKeyName.includes("F Major")
              ? jaNoteNamesFlat
              : jaNoteNamesSharp;
          const name = names[midiNote % 12];
          const pitch = { note: midiNote, y: y, name: name };
          notesOnScreen.push({
            x: canvas.width + 20,
            y: y,
            pitch: pitch,
            id: Date.now() + Math.random(),
            judged: false,
            missed: false,
          });
        } else {
          // Normal Mode Logic - 1音ずつ生成
          if (currentChordIndex >= currentProgression.length) {
            return; // 進行が終了
          }

          const chordRoman = currentProgression[currentChordIndex];
          const chord = getChordFromProgression(currentKeyName, chordRoman);

          if (!chord || !chord.notes[currentNoteInChordIndex]) return;

          let midiNote = chord.notes[currentNoteInChordIndex];

          // C4 (60) から G5 (79) の範囲に収める
          while (midiNote < 60) {
            midiNote += 12;
          }
          while (midiNote > 79) {
            midiNote -= 12;
          }

          const { y, name } = getNoteInfo(midiNote, currentKeyName);
          const pitch = { note: midiNote, y: y, name: name };

          notesOnScreen.push({
            x: canvas.width + 20,
            y: y,
            pitch: pitch,
            id: Date.now() + Math.random(),
            judged: false,
            missed: false,
          });

          // 次の音/コードへインデックスを進める
          currentNoteInChordIndex++;
          if (currentNoteInChordIndex >= chord.notes.length) {
            currentNoteInChordIndex = 0;
            currentChordIndex++;

            // 次のコード情報を表示
            if (currentChordIndex < currentProgression.length) {
              const nextChord = getChordFromProgression(
                currentKeyName,
                currentProgression[currentChordIndex]
              );
              if (nextChord) {
                chordDisplay.textContent = `コード: ${nextChord.name}`;
              }
            } else {
              chordDisplay.textContent = `コード: 終了`;
            }
          }
        }
      }

      let noteGeneratorInterval;
      function gameLoop() {
        if (!gameRunning) return;
        notesOnScreen.forEach((note) => {
          note.x -= noteSpeed;
          if (
            note.x < JUDGEMENT_LINE_X - JUDGEMENT_AREA_WIDTH &&
            !note.judged &&
            !note.missed
          ) {
            note.missed = true;
            showResult(false, note);
          }
        });

        textEffects.forEach((e) => {
          e.life--;
          e.y -= 0.5;
        });
        textEffects = textEffects.filter((e) => e.life > 0);
        highlightEffects.forEach((e) => e.life--);
        highlightEffects = highlightEffects.filter((e) => e.life > 0);
        notesOnScreen = notesOnScreen.filter((note) => note.x > -20);

        draw();
        requestAnimationFrame(gameLoop);
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawStaff();
        drawHighlights();
        notesOnScreen.forEach(drawNote);
        drawTextEffects();
      }

      function updateNoteGenerationInterval() {
        if (noteGeneratorInterval) clearInterval(noteGeneratorInterval);
        const interval =
          difficulty === "Normal"
            ? NOTE_GENERATION_INTERVAL / 3 // Normalモードは3倍速でノート生成
            : NOTE_GENERATION_INTERVAL;
        noteGeneratorInterval = setInterval(generateNote, interval / noteSpeed);
      }

      function startGame() {
        if (gameRunning) return;
        const availableKeys = Object.keys(SCALES).filter(
          (k) => SCALES[k].progressions && SCALES[k].progressions.length > 0
        );
        currentKeyName =
          availableKeys[Math.floor(Math.random() * availableKeys.length)];
        keyDisplay.textContent = `キー: ${currentKeyName}`;

        score.max =
          difficulty === "Easy" ? EASY_GAME_LENGTH : NORMAL_GAME_CHORDS * 3;

        if (difficulty === "Normal") {
          const progressions = SCALES[currentKeyName].progressions;
          currentProgression =
            progressions[Math.floor(Math.random() * progressions.length)];
          currentChordIndex = 0;
          currentNoteInChordIndex = 0;

          const firstChord = getChordFromProgression(
            currentKeyName,
            currentProgression[0]
          );
          if (firstChord) {
            chordDisplay.textContent = `コード: ${firstChord.name}`;
          }
          chordDisplay.classList.remove("hidden");
        } else {
          chordDisplay.classList.add("hidden");
        }

        gameRunning = true;
        notesOnScreen = [];
        textEffects = [];
        highlightEffects = [];
        score.correct = 0;
        score.total = 0;
        updateScore();
        updateNoteGenerationInterval();
        gameLoop();
      }

      function stopGame() {
        gameRunning = false;
        clearInterval(noteGeneratorInterval);
      }

      function endGame() {
        stopGame();
        finalScoreSpan.textContent = score.correct;
        finalMaxScoreSpan.textContent = score.max;
        gameOverScreen.classList.remove("hidden");
        gameOverScreen.classList.add("flex");
      }

      function restartGame() {
        gameOverScreen.classList.add("hidden");
        gameOverScreen.classList.remove("flex");
        startGame();
      }

      function showResult(correct, note) {
        score.total++;
        if (correct) {
          score.correct++;
          resultDisplay.textContent = "良";
          resultDisplay.className =
            "absolute top-1/2 left-1/3 -translate-x-1/2 -translate-y-1/2 text-8xl font-bold text-yellow-400 result-animation";
          effectColor = "#ffc107";
        } else {
          resultDisplay.textContent = "不可";
          resultDisplay.className =
            "absolute top-1/2 left-1/3 -translate-x-1/2 -translate-y-1/2 text-8xl font-bold text-red-500 result-animation";
          effectColor = "#ef4444";
        }
        if (note) {
          textEffects.push({
            text: note.pitch.name,
            x: note.x,
            y: note.y - 30,
            life: 60,
            color: effectColor,
          });
        }
        updateScore();
        setTimeout(() => {
          resultDisplay.textContent = "";
        }, 800);
        if (score.total >= score.max) {
          endGame();
        }
      }

      function updateScore() {
        correctCountSpan.textContent = score.correct;
        totalCountSpan.textContent = score.total;
        const accuracy =
          score.total === 0
            ? 0
            : Math.round((score.correct / score.total) * 100);
        accuracySpan.textContent = accuracy;
      }

      function initAudio() {
        if (!audioCtx) {
          try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          } catch (e) {
            console.error("Web Audio API is not supported.");
          }
        }
      }

      function playNoteSound(midiNote, duration = 1.5) {
        if (!audioCtx) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        const freq = 440 * 2 ** ((midiNote - 69) / 12);
        oscillator.type = "triangle";
        oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);

        const now = audioCtx.currentTime;
        gainNode.gain.cancelScheduledValues(now);
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(volume, now + 0.02);
        gainNode.gain.exponentialRampToValueAtTime(volume * 0.5, now + 0.2);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration);

        oscillator.start(now);
        oscillator.stop(now + duration);
      }

      connectButton.addEventListener("click", async () => {
        initAudio();
        if (!navigator.bluetooth) {
          statusDisplay.textContent =
            "Web Bluetooth APIはこのブラウザではサポートされていません。";
          statusDisplay.className =
            "text-center md:text-left text-red-800 bg-red-100 px-4 py-2 rounded-md text-sm";
          return;
        }
        try {
          statusDisplay.textContent = "Bluetooth MIDIデバイスをスキャン中...";
          statusDisplay.className =
            "text-center md:text-left text-blue-800 bg-blue-100 px-4 py-2 rounded-md text-sm";
          const device = await navigator.bluetooth.requestDevice({
            filters: [{ services: ["03b80e5a-ede8-4b33-a751-6ce34ec4c700"] }],
          });
          statusDisplay.textContent = `デバイス [${device.name}] に接続中...`;
          device.addEventListener("gattserverdisconnected", onDisconnected);
          const server = await device.gatt.connect();
          const service = await server.getPrimaryService(
            "03b80e5a-ede8-4b33-a751-6ce34ec4c700"
          );
          const characteristic = await service.getCharacteristic(
            "7772e5db-3868-4112-a1a9-f2669d106bf3"
          );
          await characteristic.startNotifications();
          characteristic.addEventListener(
            "characteristicvaluechanged",
            handleCharacteristicValueChanged
          );
          statusDisplay.textContent = `接続成功: [${device.name}]。演奏を開始してください！`;
          statusDisplay.className =
            "text-center md:text-left text-green-800 bg-green-100 px-4 py-2 rounded-md text-sm";
          if (!gameRunning) startGame();
        } catch (error) {
          console.error("Bluetooth接続エラー:", error);
          statusDisplay.textContent =
            "Bluetooth接続に失敗しました: " + error.message;
          statusDisplay.className =
            "text-center md:text-left text-red-800 bg-red-100 px-4 py-2 rounded-md text-sm";
          if (gameRunning) stopGame();
        }
      });

      function onDisconnected(event) {
        const device = event.target;
        statusDisplay.textContent = `デバイス [${device.name}] との接続が切れました。`;
        statusDisplay.className =
          "text-center md:text-left text-yellow-800 bg-yellow-100 px-4 py-2 rounded-md text-sm";
        if (gameRunning) stopGame();
      }

      function handleCharacteristicValueChanged(event) {
        const value = event.target.value;
        if (value.byteLength < 3) return;
        const status = value.getUint8(2);
        if ((status & 0xf0) === 0x90) {
          // Note On
          const velocity = value.getUint8(4);
          if (velocity > 0) {
            const noteNumber = value.getUint8(3);
            onMidiNoteOn(noteNumber);
          }
        }
      }

      function onMidiNoteOn(noteNumber) {
        playNoteSound(noteNumber);
        const pitchInfo = getNoteInfo(noteNumber, currentKeyName);
        if (pitchInfo) {
          highlightEffects.push({ y: pitchInfo.y, life: 30 });
        }
        handleKeyPress(noteNumber);
      }

      function handleKeyPress(noteNumber) {
        if (!gameRunning) return;
        const targetNote = notesOnScreen.find(
          (note) =>
            !note.judged &&
            note.x > JUDGEMENT_LINE_X - JUDGEMENT_AREA_WIDTH &&
            note.x < JUDGEMENT_LINE_X + JUDGEMENT_AREA_WIDTH &&
            note.pitch.note === noteNumber
        );
        if (targetNote) {
          targetNote.judged = true;
          targetNote.correct = true;
          showResult(true, targetNote);
        }
      }

      function createPianoKeyboard() {
        const keyboardContainer = document.getElementById("piano-keyboard");
        if (!keyboardContainer) return;
        keyboardContainer.innerHTML = "";
        const noteRange = { start: 60, end: 79 };
        const isBlackKey = [
          false,
          true,
          false,
          true,
          false,
          false,
          true,
          false,
          true,
          false,
          true,
          false,
        ];

        const whiteKeyNotes = Array.from(
          { length: noteRange.end - noteRange.start + 1 },
          (_, i) => noteRange.start + i
        ).filter((note) => !isBlackKey[note % 12]);
        const whiteKeyCount = whiteKeyNotes.length;

        const whiteKeyWidth = 100 / whiteKeyCount;
        let whiteKeyIndex = 0;

        for (
          let midiNote = noteRange.start;
          midiNote <= noteRange.end;
          midiNote++
        ) {
          const key = document.createElement("div");
          key.dataset.note = midiNote;
          const isBlack = isBlackKey[midiNote % 12];

          if (isBlack) {
            key.className = "black-key";
            key.style.width = `${whiteKeyWidth * 0.6}%`;
            key.style.height = "60%";
            key.style.left = `${(whiteKeyIndex - 0.3) * whiteKeyWidth}%`;
          } else {
            key.className = "white-key";
            key.style.width = `${whiteKeyWidth}%`;
            key.style.height = "100%";
            key.style.left = `${whiteKeyIndex * whiteKeyWidth}%`;
            whiteKeyIndex++;
          }

          const handlePress = (e) => {
            e.preventDefault();
            initAudio();
            if (!gameRunning) startGame();
            onMidiNoteOn(midiNote);
            key.classList.add("active");
          };

          const handleRelease = () => key.classList.remove("active");

          key.addEventListener("mousedown", handlePress);
          key.addEventListener("mouseup", handleRelease);
          key.addEventListener("mouseleave", handleRelease);
          key.addEventListener("touchstart", handlePress, { passive: false });
          key.addEventListener("touchend", handleRelease);

          keyboardContainer.appendChild(key);
        }
      }

      // --- 初期化処理 ---
      difficultyButtons.forEach((button) => {
        button.addEventListener("click", () => {
          difficulty = button.dataset.difficulty;
          difficultyButtons.forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");
          if (gameRunning) restartGame();
        });
      });

      speedSlider.addEventListener("input", (e) => {
        noteSpeed = parseFloat(e.target.value);
        speedValueSpan.textContent = noteSpeed.toFixed(1);
        if (gameRunning) {
          updateNoteGenerationInterval();
        }
      });
      volumeSlider.addEventListener("input", (e) => {
        volume = parseFloat(e.target.value);
        volumeValueSpan.textContent = volume.toFixed(2);
      });
      window.addEventListener("resize", () => {
        resizeCanvas();
        createPianoKeyboard();
      });
      restartButton.addEventListener("click", restartGame);

      // --- 初期描画 ---
      resizeCanvas();
      createPianoKeyboard();
      draw();
    </script>
  </body>
</html>
